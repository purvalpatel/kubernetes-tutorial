servicemesh is different from kubernetes service. <br>
They solve different problems even though both deal with networking. <br>

| Component              | Purpose                                                                    |
| ---------------------- | -------------------------------------------------------------------------- |
| **Ingress Controller** | Manages traffic **coming from outside** the cluster → into services.       |
| **Service Mesh**       | Manages **internal traffic** between microservices **inside** the cluster. |



### Kubernetes service: <br>
- Exposes stable virtual IPs for accessible stable virtual pods.
- Basic load balancing and service discovery.
- Handles basic load balancing and routing. 

### Service mesh: <br>

- Handles **secure, reliable, and observable communication** between services. <br>
- Adds advanced logic like: <br>
    mTLS (encryption) <br>
    Retries, timeouts, circuit breaking <br>
    Traffic shifting (canary, A/B tests) <br>
    Tracing, metrics <br>
    Policy enforcement <br>

**Higher-level networking; not part of Kubernetes core.** <br>

| Feature        | Kubernetes Service | Service Mesh                      |
| -------------- | ------------------ | --------------------------------- |
| Network Layer  | L3/L4              | L7 (HTTP/gRPC aware)              |
| Discovery      | Basic              | Advanced                          |
| Load Balancing | Round-robin        | Weighted, locality-aware, retries |
| Security       | None               | mTLS, identities, policies        |
| Observability  | Minimal            | Full metrics + tracing            |

**ServiceMesh does not replace kubernete services.** <br>
It runs on the top of that. <br>

**It works as a sidecar proxies.** <br>
example: Istio, Linkerd (older versions), Consul, Kuma. <br> <br>

Istio:
-----
its a traffic manager and security manager for your microservice. <br>

- Traffic control
- Security
- Observability

Istio traffic flow:
------------------
```
Service A (App)
   ↓
iptables (Pod A)
   ↓
Envoy A (outbound proxy)
   ↓  ← mTLS / routing / retries
Network
   ↓
Envoy B (inbound proxy)
   ↓  ← auth / policy / metrics
iptables (Pod B)
   ↓
Service B (App)
```
Envoy:
----
Envoy is a proxy like NGINX, but optimized for microservices and service meshes, not for websites. <br>
Envoy is a high-performance, cloud-native network proxy used to manage all communication between services—without changing application code. <br>
Envoy is a smart, programmable network proxy that sits beside your application and handles traffic, security, and observability. <br>



Istio + Prometheus integration:
------------------------------

Prometheus only can collect Node Metrics, Pod metrics. <br>
Istio can generate detailed telemetry which monitoring tools can use. <br>

## Why Istio needs Prometheus? <br>

Istio sidecar proxies (Envoy) generate rich metrics for: <br>
### ✔ Traffic (Canary,Blue/Green,A/B testing,Fault injection,Circuit breaking)
- request count
- request duration
- success/error rate
- per-path metrics
- per-service metrics
### ✔ Reliability
- retries
- timeouts
- circuit breaker triggers
- connection errors
### ✔ Security
- mTLS handshake
- certificate failures
- unauthorized requests
### ✔ Mesh internals
- sidecar uptime
- pilot synchronization
- cluster-wide mesh health
- Prometheus scrapes all this data


#### Install istio:
**Installation Flow:** <br>
Install Istio control plane <br>
Verify Istio is healthy <br>
Enable sidecar injection only for selected namespaces <br>
Gradually onboard applications <br>
(Optional) Enable mTLS, routing, telemetry <br>

```
curl -L https://istio.io/downloadIstio | sh -
```

This will install istioctl libraries. <br>
Now deploy istio service pods.
```
cd istio-1.28.0/bin
export PATH=$PWD/bin:$PATH

istioctl install --set profile=default -y
```
This will install: <br>
`istiod` <br>
Ingress Gateway <br>
`CRDs` <br>

Check status of resources which is deployed in istio.
```
kubectl get all -n istio-system
```

Now label namespace to enable sidecar injection.
```
kubectl label namespace default istio-injection=enabled

kubectl label namespace monitoring istio-injection=enabled

# Remove label
kubectl label namespace monitoring istio-injection-
```

Now restart the deployment:
```
kubectl rollout restart deployment prometheus-grafana -n monitoring
```
Now check the pod contains the istio side-car contaier or not:

```
kubectl describe pod prometheus-grafana-56c758559f-sglk2 -n monitoring
```

<img width="1125" height="587" alt="image" src="https://github.com/user-attachments/assets/824b17a2-376a-476f-beff-744ad36ab0de" />

This means Istio is now connected to your app. <br>
Restart deployment check the status. <br>
Confirm traffic is Flowing via Istio:
```
istioctl proxy-status
```
<img width="1374" height="100" alt="image" src="https://github.com/user-attachments/assets/fe30f60f-7c3e-481b-a9ce-86ae2907d84c" />

Verify sidecar ingestion in the Pod:
```
kubectl get pod attu-fcbbdc4bc-p4sjg -n milvus -o jsonpath='{.spec.containers[*].name}'
```
Quick healthcheck:
```
istioctl proxy-config endpoints attu-fcbbdc4bc-p4sjg -n milvus
```

## Expose app with Istio  Gateway + Virtualservice:

Istio does NOT use Kubernetes Ingress. <br>
It uses Gateway and virtual service. <br>

Gateway (80/443) -> Virtual service (Gateway, Internal port ) <br>

Means correct pattern is, <br>
1. One Gateway (80/443)
2. Multiple virtualservice ( different applications internal port and domains )

gateway.yaml
```
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: myapp-gateway
spec:
  selector:
    istio: ingressgateway   # use the default istio ingress gateway
  servers:
    - port:
        number: 80
        name: http
        protocol: HTTP
      hosts:
        - "example.com"      # your domain
```

virtualservice.yaml
```
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: myapp
spec:
  hosts:
    - "example.com"
  gateways:
    - myapp-gateway
  http:
    - route:
        - destination:
            host: myapp
            port:
              number: 8080
```

Now your app is integrated with istio:
```
http://<node-ip>:<istio-nodeport>
```


